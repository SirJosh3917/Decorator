using System;
using System.Collections.Generic;
using System.Text;

namespace Decorator.Attributes
{
	/// <summary>
	/// Represents an item that should be "flattened".
	/// </summary>
	/// <remarks>
	/// Example of what this would do in practice:
	/// <code>
	/// [Message("internal")]
	/// public class Internal {
	///		[Position(0), Required]
	///		public string HelloWorld { get; set; }
	///		
	///		[Position(1), Required]
	///		public string AnotherHelloWorld { get; set; }
	/// }
	/// 
	/// [Message("main")]
	/// public class Main {
	///		[Position(0), Required]
	///		public Internal ExampleInternal { get; set; }
	///		
	///		[Position(1), Required, Flatten]
	///		public Internal ExampleFlattenedInternal { get; set; }
	/// }
	/// 
	/// The result of serializing Main with each internal having values of 'test', and 'test2' respectively, you'd see in your serialized object array:
	/// 
	///				// the Internal at position 0
	/// object[] {	new Internal { HelloWorld = "test", AnotherHelloWorld = "test2" },
	/// 
	///				// the flattened Internal at position 1
	///				"test1", "test2" };
	/// </code>
	/// </remarks>
	/// <seealso cref="System.Attribute" />
	/// <autogeneratedoc />
	[AttributeUsage(AttributeTargets.Property, AllowMultiple = true, Inherited = true)]
	public sealed class FlattenAttribute : Attribute
	{
		public FlattenAttribute()
		{

		}
	}
}
