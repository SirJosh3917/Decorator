using Decorator.Attributes;
using Decorator.Exceptions;

using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Decorator
{
	/// <summary>Serialize a <see cref="TClass" /> to a <see cref="BaseMessage" /></summary>
	public static class Serializer
	{
		private static FunctionWrapper _serialize;
		
		static Serializer()
		{
			_serialize = new FunctionWrapper(typeof(Serializer).GetMethods()[0]);
		}
		
		/// <summary>Serializes the specified item.</summary>
		/// <typeparam name="TClass">The type of the class.</typeparam>
		/// <param name="itm">The item.</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		public static BaseMessage SerializeItem<TClass>(TClass itm)
			where TClass : class
		{
			var def = MessageManager.GetDefinitionFor<TClass>();

			if (def == null) throw new MissingAttributeException(typeof(MessageAttribute), typeof(TClass));

			var data = new List<object>(def.Properties.Length);

			var lastPosAttrib = 0;
			var position = 0;

			foreach (var i in def.Properties)
			{
				var increase = i.PositionInt - lastPosAttrib;
				position += increase;
				lastPosAttrib = i.PositionInt;

				if (i.Flatten)
				{
					var serialized = _serialize.GetMethodFor(i.Type)(null, new object[] { i.Get(itm) });
					var args = ((BaseMessage)serialized).Arguments;
					data.InsertRange(position, args);
					position += args.Length - 1;
				}
				else
				{
					data.Insert(position, i.Get(itm));
				}
			}

			return new BasicMessage(def.Type, data.ToArray());
		}

		/// <summary>Serializes the items specified.</summary>
		/// <typeparam name="TClass">The type of the class.</typeparam>
		/// <param name="items">The items.</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		public static BaseMessage SerializeItems<TClass>(IEnumerable<TClass> items)
			where TClass : class
		{
			var def = MessageManager.GetDefinitionFor<TClass>();

			var itms = items.ToArray();

			var objs = new object[itms.Length * def.Properties.Length];

			for (var i = 0; i < itms.Length; i++)
				foreach (var j in def.Properties)
					objs[(i * def.Properties.Length) + (int)j.Position] = j.Get(itms[i]);

			return new BasicMessage(def.Type, objs);
		}
	}
}